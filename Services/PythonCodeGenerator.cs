using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using LangraphIDE.Helpers;
using LangraphIDE.Models;

namespace LangraphIDE.Services
{
    public class PythonCodeGenerator
    {
        private LangraphConfig _config = new();
        // Maps nodeId -> LLM variable name for per-node LLM initialization
        private Dictionary<string, string> _llmVarNames = new();

        public GeneratedCode Generate(AgentGraphData graphData, LangraphConfig? config = null)
        {
            _config = config ?? new LangraphConfig();
            _llmVarNames = new Dictionary<string, string>();
            var result = new GeneratedCode();

            // Collect all imports
            var imports = new HashSet<string>
            {
                "from typing import TypedDict, Annotated, Sequence",
                "from langgraph.graph import StateGraph, END"
            };

            // Add per-node LLM provider imports
            var llmNodes = graphData.Nodes.Where(n => n.Type == NodeType.LLM).ToList();
            foreach (var llmNode in llmNodes)
            {
                var providerKey = LlmProviderTemplates.DetectProvider(llmNode.Name);
                if (LlmProviderTemplates.Providers.TryGetValue(providerKey, out var provider))
                {
                    imports.Add(provider.ImportStatement);
                }

                // Assign a unique variable name for this LLM node
                var funcIdent = StringHelpers.ToPythonIdentifier(llmNode.DisplayName ?? llmNode.Name);
                _llmVarNames[llmNode.Id] = llmNodes.Count == 1 ? "llm" : $"llm_{funcIdent}";
            }

            // Generate State class
            var stateFields = InferStateFields(graphData);
            var stateCode = GenerateStateClass(stateFields);

            // Generate node functions
            var nodeFunctions = new List<GeneratedNodeFunction>();
            var nodeOrder = TopologicalSort(graphData);

            foreach (var nodeData in nodeOrder)
            {
                var func = GenerateNodeFunction(nodeData, graphData);
                if (func != null)
                {
                    nodeFunctions.Add(func);
                    foreach (var imp in func.RequiredImports)
                        imports.Add(imp);
                }
            }

            // Generate graph building code
            var graphCode = GenerateGraphBuildCode(graphData, nodeFunctions);

            // Assemble full code
            var sb = new StringBuilder();

            // Header comment
            sb.AppendLine($"# Agent Graph: {graphData.Metadata.Name}");
            sb.AppendLine($"# Generated by AI Agent Factory");
            sb.AppendLine($"# {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine();

            // Imports
            foreach (var imp in imports.OrderBy(i => i))
            {
                sb.AppendLine(imp);
            }
            sb.AppendLine();

            // LLM initialization (per-node)
            if (llmNodes.Any())
            {
                sb.AppendLine("# Initialize LLMs");
                foreach (var llmNode in llmNodes)
                {
                    var providerKey = LlmProviderTemplates.DetectProvider(llmNode.Name);
                    if (!LlmProviderTemplates.Providers.TryGetValue(providerKey, out var providerCfg))
                        continue;

                    var model = llmNode.Parameters.GetValueOrDefault("model", providerCfg.DefaultModel);
                    var baseUrl = llmNode.Parameters.GetValueOrDefault("base_url", "");
                    var varName = _llmVarNames.GetValueOrDefault(llmNode.Id, "llm");

                    // Build multi-line initialization using config variables from [llm] section
                    sb.AppendLine($"{varName} = {providerCfg.ClassName}(");
                    var guiModel = llmNode.Parameters.GetValueOrDefault("model", "");
                    if (!string.IsNullOrEmpty(guiModel))
                        sb.AppendLine($"    model=\"{guiModel}\",");
                    else if (!string.IsNullOrEmpty(providerCfg.ModelConfigVar))
                        sb.AppendLine($"    model={providerCfg.ModelConfigVar} or \"{providerCfg.DefaultModel}\",");
                    else
                        sb.AppendLine($"    model=\"{providerCfg.DefaultModel}\",");

                    // API key from config variable
                    if (!string.IsNullOrEmpty(providerCfg.ApiKeyConfigVar))
                        sb.AppendLine($"    {providerCfg.ApiKeyParameterName}={providerCfg.ApiKeyConfigVar},");

                    // Base URL: GUI value takes precedence over config variable
                    if (!string.IsNullOrEmpty(baseUrl))
                    {
                        sb.AppendLine($"    {providerCfg.UrlParameterName}=\"{baseUrl}\",");
                    }
                    else if (!string.IsNullOrEmpty(providerCfg.UrlConfigVar))
                    {
                        sb.AppendLine($"    {providerCfg.UrlParameterName}={providerCfg.UrlConfigVar} or None,");
                    }

                    var temperature = llmNode.Parameters.GetValueOrDefault("temperature", "");
                    if (!string.IsNullOrEmpty(temperature) && temperature != "0.7")
                        sb.AppendLine($"    temperature={temperature},");

                    var maxTokens = llmNode.Parameters.GetValueOrDefault("max_tokens", "");
                    if (!string.IsNullOrEmpty(maxTokens) && maxTokens != "4096")
                        sb.AppendLine($"    max_tokens={maxTokens},");

                    sb.AppendLine(")");
                }
                sb.AppendLine();
            }

            // State class
            sb.AppendLine(stateCode);
            sb.AppendLine();

            // Node functions
            foreach (var func in nodeFunctions)
            {
                sb.AppendLine(func.FunctionCode);
                sb.AppendLine();
            }

            // Graph building
            sb.AppendLine(graphCode);

            result.Imports = imports.ToList();
            result.StateClassCode = stateCode;
            result.NodeFunctions = nodeFunctions;
            result.GraphBuildCode = graphCode;
            result.FullCode = sb.ToString();

            return result;
        }

        private List<StateFieldData> InferStateFields(AgentGraphData graphData)
        {
            var fields = new Dictionary<string, StateFieldData>();

            // Add default fields
            fields["input"] = new StateFieldData { Name = "input", Type = "str", Description = "User input" };
            fields["output"] = new StateFieldData { Name = "output", Type = "str", Description = "Final output" };

            // Infer from node parameters
            foreach (var node in graphData.Nodes)
            {
                foreach (var outputVar in node.OutputVariables)
                {
                    if (!fields.ContainsKey(outputVar))
                    {
                        fields[outputVar] = new StateFieldData { Name = outputVar, Type = "str" };
                    }
                }

                // Check specific parameter patterns
                foreach (var param in node.Parameters)
                {
                    if (param.Key.EndsWith("_key") && !string.IsNullOrEmpty(param.Value))
                    {
                        var fieldName = param.Value;
                        if (!fields.ContainsKey(fieldName))
                        {
                            fields[fieldName] = new StateFieldData { Name = fieldName, Type = "str" };
                        }
                    }
                }
            }

            // Add explicit state fields from graph data
            foreach (var field in graphData.StateFields)
            {
                fields[field.Name] = field;
            }

            return fields.Values.ToList();
        }

        private string GenerateStateClass(List<StateFieldData> fields)
        {
            var sb = new StringBuilder();

            if (_config.IncludeDocstrings)
            {
                sb.AppendLine("class State(TypedDict):");
                sb.AppendLine("    \"\"\"State schema for the agent graph.\"\"\"");
            }
            else
            {
                sb.AppendLine("class State(TypedDict):");
            }

            foreach (var field in fields)
            {
                var pythonType = MapToPythonType(field.Type);
                if (!string.IsNullOrEmpty(field.Description) && _config.IncludeDocstrings)
                {
                    sb.AppendLine($"    {field.Name}: {pythonType}  # {field.Description}");
                }
                else
                {
                    sb.AppendLine($"    {field.Name}: {pythonType}");
                }
            }

            if (!fields.Any())
            {
                sb.AppendLine("    pass");
            }

            return sb.ToString();
        }

        private GeneratedNodeFunction? GenerateNodeFunction(AgentNodeData nodeData, AgentGraphData graphData)
        {
            // Skip Start and End nodes - they don't generate functions
            if (nodeData.Type == NodeType.Start || nodeData.Type == NodeType.End)
                return null;

            var funcName = StringHelpers.ToPythonIdentifier(nodeData.DisplayName ?? nodeData.Name);
            funcName = $"{funcName}_node";

            var func = new GeneratedNodeFunction
            {
                NodeId = nodeData.Id,
                FunctionName = funcName,
                IsRouter = nodeData.Type == NodeType.Router
            };

            var sb = new StringBuilder();

            // Function signature
            if (func.IsRouter)
            {
                sb.AppendLine($"def {funcName}(state: State) -> str:");
            }
            else
            {
                sb.AppendLine($"def {funcName}(state: State) -> dict:");
            }

            // Docstring
            if (_config.IncludeDocstrings && !string.IsNullOrEmpty(nodeData.Description))
            {
                sb.AppendLine($"    \"\"\"{nodeData.Description}\"\"\"");
            }

            // Function body based on node type
            var body = GenerateNodeBody(nodeData, graphData, func);
            sb.Append(body);

            func.FunctionCode = sb.ToString();
            return func;
        }

        private string GenerateNodeBody(AgentNodeData nodeData, AgentGraphData graphData, GeneratedNodeFunction func)
        {
            var sb = new StringBuilder();
            var indent = "    ";
            var displayName = nodeData.DisplayName ?? nodeData.Name;

            // Trace: entering node
            sb.AppendLine($"{indent}print(\"[{displayName}] >>> Entering node\")");

            switch (nodeData.Type)
            {
                case NodeType.Input:
                    var inputKey = nodeData.Parameters.GetValueOrDefault("input_key", "input");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] input_key='{inputKey}', value={{repr(state.get('{inputKey}', ''))[:200]}}\")");
                    sb.AppendLine($"{indent}return {{\"{inputKey}\": state.get(\"{inputKey}\", \"\")}}");
                    break;

                case NodeType.Output:
                    var outputKey = nodeData.Parameters.GetValueOrDefault("output_key", "output");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] output_key='{outputKey}', value={{repr(state.get('{outputKey}', ''))[:200]}}\")");
                    sb.AppendLine($"{indent}return {{\"{outputKey}\": state.get(\"{outputKey}\", \"\")}}");
                    break;

                case NodeType.Prompt:
                    var template = nodeData.Parameters.GetValueOrDefault("template", "");
                    var promptOutputKey = nodeData.Parameters.GetValueOrDefault("output_key", "prompt");

                    // Escape the template for Python
                    template = template.Replace("\\", "\\\\").Replace("\"", "\\\"");
                    template = template.Replace("\n", "\\n");

                    sb.AppendLine($"{indent}template = \"\"\"{template}\"\"\"");
                    sb.AppendLine($"{indent}try:");
                    sb.AppendLine($"{indent}    prompt = template.format(**state)");
                    sb.AppendLine($"{indent}except KeyError as e:");
                    sb.AppendLine($"{indent}    print(f\"[{displayName}] WARNING: missing key {{e}}, using raw template\")");
                    sb.AppendLine($"{indent}    prompt = template");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] prompt ({{len(prompt)}} chars): {{repr(prompt)[:200]}}\")");
                    sb.AppendLine($"{indent}return {{\"{promptOutputKey}\": prompt}}");
                    break;

                case NodeType.LLM:
                    var llmInputKey = nodeData.Parameters.GetValueOrDefault("input_key", "prompt");
                    var llmOutputKey = nodeData.Parameters.GetValueOrDefault("output_key", "output");
                    var llmVar = _llmVarNames.GetValueOrDefault(nodeData.Id, "llm");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] Invoking LLM with {{len(state['{llmInputKey}'])}} chars...\")");
                    sb.AppendLine($"{indent}response = {llmVar}.invoke(state[\"{llmInputKey}\"])");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] LLM response ({{len(response.content)}} chars): {{repr(response.content)[:200]}}\")");
                    sb.AppendLine($"{indent}return {{\"{llmOutputKey}\": response.content}}");
                    break;

                case NodeType.Router:
                    var routingLogic = nodeData.Parameters.GetValueOrDefault("routing_logic", "return \"continue\"");
                    // Wrap routing logic to trace the decision
                    sb.AppendLine($"{indent}def _route(state):");
                    var lines = routingLogic.Split('\n');
                    foreach (var line in lines)
                    {
                        sb.AppendLine($"{indent}    {line}");
                    }
                    sb.AppendLine($"{indent}_decision = _route(state)");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] Routing decision: {{_decision}}\")");
                    sb.AppendLine($"{indent}return _decision");
                    break;

                case NodeType.Condition:
                    var condition = nodeData.Parameters.GetValueOrDefault("condition", "True");
                    var condOutputKey = nodeData.Parameters.GetValueOrDefault("output_key", "condition_result");
                    sb.AppendLine($"{indent}result = {condition}");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] Condition result: {{result}}\")");
                    sb.AppendLine($"{indent}return {{\"{condOutputKey}\": result}}");
                    break;

                case NodeType.Tool:
                    var code = nodeData.Parameters.GetValueOrDefault("code", "return {}");
                    func.RequiredImports.Add("import requests");  // Common for tools
                    // Indent the custom code
                    var codeLines = code.Split('\n');
                    foreach (var line in codeLines)
                    {
                        sb.AppendLine($"{indent}{line}");
                    }
                    break;

                case NodeType.RAG:
                    var ragQueryKey = nodeData.Parameters.GetValueOrDefault("query_key", "input");
                    var ragOutputKey = nodeData.Parameters.GetValueOrDefault("output_key", "prompt");
                    var ragTopK = nodeData.Parameters.GetValueOrDefault("top_k", "5");
                    var ragThreshold = nodeData.Parameters.GetValueOrDefault("threshold", "0.0");
                    var ragTagFilter = nodeData.Parameters.GetValueOrDefault("tag_filter", "");
                    var ragTemplate = nodeData.Parameters.GetValueOrDefault("prompt_template",
                        "Use the following context to answer the question.\\n\\nContext:\\n{context}\\n\\nQuestion: {query}\\n\\nAnswer:");

                    func.RequiredImports.Add("from modules.vectordb_module import init_from_config");

                    sb.AppendLine($"{indent}vdb = init_from_config()");
                    sb.AppendLine($"{indent}query = state.get(\"{ragQueryKey}\", \"\")");

                    // Build search call with optional tag filter
                    if (!string.IsNullOrEmpty(ragTagFilter))
                    {
                        var tags = string.Join("\", \"", ragTagFilter.Split(',', StringSplitOptions.TrimEntries));
                        sb.AppendLine($"{indent}results = vdb.search_text(query, top_k={ragTopK}, threshold={ragThreshold}, tag_filter=[\"{tags}\"])");
                    }
                    else
                    {
                        sb.AppendLine($"{indent}results = vdb.search_text(query, top_k={ragTopK}, threshold={ragThreshold})");
                    }

                    sb.AppendLine($"{indent}context = \"\\n\\n\".join(");
                    sb.AppendLine($"{indent}    f\"[{{r['document_filename']}}] {{r['content']}}\"");
                    sb.AppendLine($"{indent}    for r in results.get(\"results\", [])");
                    sb.AppendLine($"{indent})");

                    // Escape template for Python triple-quoted string
                    ragTemplate = ragTemplate.Replace("\\", "\\\\").Replace("\"", "\\\"");
                    ragTemplate = ragTemplate.Replace("\n", "\\n");

                    sb.AppendLine($"{indent}template = \"\"\"{ragTemplate}\"\"\"");
                    sb.AppendLine($"{indent}augmented = template.format(context=context, query=query)");
                    sb.AppendLine($"{indent}print(f\"[{displayName}] Found {{len(results.get('results', []))}} chunks, augmented prompt ({{len(augmented)}} chars)\")");
                    sb.AppendLine($"{indent}return {{\"{ragOutputKey}\": augmented}}");
                    break;

                case NodeType.Memory:
                    var memoryKey = nodeData.Parameters.GetValueOrDefault("memory_key", "data");
                    var sourceKey = nodeData.Parameters.GetValueOrDefault("source_key", "");
                    var memOutputKey = nodeData.Parameters.GetValueOrDefault("output_key", "");

                    if (!string.IsNullOrEmpty(sourceKey))
                    {
                        // Store operation
                        sb.AppendLine($"{indent}print(f\"[{displayName}] Storing '{sourceKey}' -> memory['{memoryKey}']\")");
                        sb.AppendLine($"{indent}memory = state.get(\"memory\", {{}})");
                        sb.AppendLine($"{indent}memory[\"{memoryKey}\"] = state.get(\"{sourceKey}\", \"\")");
                        sb.AppendLine($"{indent}return {{\"memory\": memory}}");
                    }
                    else if (!string.IsNullOrEmpty(memOutputKey))
                    {
                        // Retrieve operation
                        sb.AppendLine($"{indent}memory = state.get(\"memory\", {{}})");
                        sb.AppendLine($"{indent}value = memory.get(\"{memoryKey}\", \"\")");
                        sb.AppendLine($"{indent}print(f\"[{displayName}] Retrieved memory['{memoryKey}']: {{repr(value)[:200]}}\")");
                        sb.AppendLine($"{indent}return {{\"{memOutputKey}\": value}}");
                    }
                    else
                    {
                        sb.AppendLine($"{indent}return {{}}");
                    }
                    break;

                default:
                    // Custom node with Python code
                    if (!string.IsNullOrEmpty(nodeData.PythonCode))
                    {
                        var customLines = nodeData.PythonCode.Split('\n');
                        foreach (var line in customLines)
                        {
                            sb.AppendLine($"{indent}{line}");
                        }
                    }
                    else
                    {
                        sb.AppendLine($"{indent}return {{}}");
                    }
                    break;
            }

            return sb.ToString();
        }

        private string GenerateGraphBuildCode(AgentGraphData graphData, List<GeneratedNodeFunction> nodeFunctions)
        {
            var sb = new StringBuilder();

            sb.AppendLine("# Build the graph");
            sb.AppendLine($"{_config.GraphVariableName} = StateGraph(State)");
            sb.AppendLine();

            // Add nodes
            sb.AppendLine("# Add nodes");
            foreach (var func in nodeFunctions.Where(f => !f.IsRouter))
            {
                var nodeData = graphData.Nodes.First(n => n.Id == func.NodeId);
                var nodeName = StringHelpers.ToPythonIdentifier(nodeData.DisplayName ?? nodeData.Name);
                sb.AppendLine($"{_config.GraphVariableName}.add_node(\"{nodeName}\", {func.FunctionName})");
            }
            sb.AppendLine();

            // Find entry point (node after Start, or first node without incoming edges)
            var entryNode = FindEntryPoint(graphData);
            if (entryNode != null)
            {
                var entryName = StringHelpers.ToPythonIdentifier(entryNode.DisplayName ?? entryNode.Name);
                sb.AppendLine("# Set entry point");
                sb.AppendLine($"{_config.GraphVariableName}.set_entry_point(\"{entryName}\")");
                sb.AppendLine();
            }

            // Add edges
            sb.AppendLine("# Add edges");
            var routerNodes = graphData.Nodes.Where(n => n.Type == NodeType.Router).ToList();
            var routerNodeIds = routerNodes.Select(n => n.Id).ToHashSet();

            foreach (var edge in graphData.Edges)
            {
                var fromNode = graphData.Nodes.FirstOrDefault(n => n.Id == edge.FromNodeId);
                var toNode = graphData.Nodes.FirstOrDefault(n => n.Id == edge.ToNodeId);

                if (fromNode == null || toNode == null) continue;

                // Skip edges from Start node (handled by entry point)
                if (fromNode.Type == NodeType.Start) continue;

                // Skip edges from Router nodes (handled separately)
                if (fromNode.Type == NodeType.Router) continue;

                var fromName = StringHelpers.ToPythonIdentifier(fromNode.DisplayName ?? fromNode.Name);

                if (toNode.Type == NodeType.End)
                {
                    sb.AppendLine($"{_config.GraphVariableName}.add_edge(\"{fromName}\", END)");
                }
                else
                {
                    var toName = StringHelpers.ToPythonIdentifier(toNode.DisplayName ?? toNode.Name);
                    sb.AppendLine($"{_config.GraphVariableName}.add_edge(\"{fromName}\", \"{toName}\")");
                }
            }

            // Handle conditional edges from Router nodes
            foreach (var router in routerNodes)
            {
                var routerFunc = nodeFunctions.FirstOrDefault(f => f.NodeId == router.Id);
                if (routerFunc == null) continue;

                var routerEdges = graphData.Edges.Where(e => e.FromNodeId == router.Id).ToList();
                if (!routerEdges.Any()) continue;

                var routerName = StringHelpers.ToPythonIdentifier(router.DisplayName ?? router.Name);
                sb.AppendLine();
                sb.AppendLine($"# Conditional edges from {routerName}");
                sb.AppendLine($"{_config.GraphVariableName}.add_conditional_edges(");
                sb.AppendLine($"    \"{routerName}\",");
                sb.AppendLine($"    {routerFunc.FunctionName},");
                sb.AppendLine("    {");

                foreach (var edge in routerEdges)
                {
                    var toNode = graphData.Nodes.FirstOrDefault(n => n.Id == edge.ToNodeId);
                    if (toNode == null) continue;

                    var condition = edge.Condition ?? edge.Label ?? "default";
                    if (toNode.Type == NodeType.End)
                    {
                        sb.AppendLine($"        \"{condition}\": END,");
                    }
                    else
                    {
                        var toName = StringHelpers.ToPythonIdentifier(toNode.DisplayName ?? toNode.Name);
                        sb.AppendLine($"        \"{condition}\": \"{toName}\",");
                    }
                }

                sb.AppendLine("    }");
                sb.AppendLine(")");
            }

            sb.AppendLine();
            sb.AppendLine("# Compile the graph");
            sb.AppendLine($"{_config.AppVariableName} = {_config.GraphVariableName}.compile()");
            sb.AppendLine($"print(\"[Graph] Compiled successfully.\")");
            sb.AppendLine();
            sb.AppendLine("print(\"[Graph] Starting execution...\")");
            sb.AppendLine("result = app.invoke({\"input\": ctx or \"\"})");
            sb.AppendLine("print(f\"[Graph] Execution complete. Result keys: {list(result.keys())}\")");
            sb.AppendLine("print(result)");

            return sb.ToString();
        }

        private AgentNodeData? FindEntryPoint(AgentGraphData graphData)
        {
            // Find the Start node
            var startNode = graphData.Nodes.FirstOrDefault(n => n.Type == NodeType.Start);

            if (startNode != null)
            {
                // Find the node connected to Start
                var edgeFromStart = graphData.Edges.FirstOrDefault(e => e.FromNodeId == startNode.Id);
                if (edgeFromStart != null)
                {
                    return graphData.Nodes.FirstOrDefault(n => n.Id == edgeFromStart.ToNodeId);
                }
            }

            // Fallback: find first node without incoming edges (excluding Start/End)
            var nodesWithIncoming = graphData.Edges.Select(e => e.ToNodeId).ToHashSet();
            return graphData.Nodes.FirstOrDefault(n =>
                n.Type != NodeType.Start &&
                n.Type != NodeType.End &&
                !nodesWithIncoming.Contains(n.Id));
        }

        private List<AgentNodeData> TopologicalSort(AgentGraphData graphData)
        {
            var result = new List<AgentNodeData>();
            var visited = new HashSet<string>();
            var inProgress = new HashSet<string>();

            void Visit(string nodeId)
            {
                if (visited.Contains(nodeId)) return;
                if (inProgress.Contains(nodeId)) return; // Cycle detected

                inProgress.Add(nodeId);

                // Visit dependencies (nodes with edges TO this node)
                foreach (var edge in graphData.Edges.Where(e => e.ToNodeId == nodeId))
                {
                    Visit(edge.FromNodeId);
                }

                inProgress.Remove(nodeId);
                visited.Add(nodeId);

                var node = graphData.Nodes.FirstOrDefault(n => n.Id == nodeId);
                if (node != null)
                    result.Add(node);
            }

            foreach (var node in graphData.Nodes)
            {
                Visit(node.Id);
            }

            return result;
        }

        private string MapToPythonType(string type)
        {
            return type.ToLower() switch
            {
                "str" or "string" => "str",
                "int" or "integer" => "int",
                "float" or "double" or "number" => "float",
                "bool" or "boolean" => "bool",
                "list" or "array" => "list",
                "dict" or "dictionary" or "object" => "dict",
                _ => "str"
            };
        }
    }
}
